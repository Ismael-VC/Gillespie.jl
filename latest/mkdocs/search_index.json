{
    "docs": [
        {
            "location": "/", 
            "text": "Gillespie.jl: Stochastic Simulation Algorithm in Julia\n\n\n\n\nGillespie.jl: Stochastic Simulation Algorithm in Julia\n\n\nIntroduction\n\n\nInstallation\n\n\nExample\n\n\nApplication programming interface\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nGillespie.jl\n provides an implementation of \nGillespie's direct method\n for performing stochastic simulations, which are widely used in many fields, including systems biology and epidemiology. It borrows the basic interface (although none of the code) from the R library \nGillespieSSA\n by Mario Pineda-Krch, although \nGillespie.jl\n only implements the standard exact method at present, whereas \nGillespieSSA\n also includes tau-leaping, \netc.\n.\n\n\n\n\nInstallation\n\n\nGillespie.jl\n can be installed from the Julia read-eval-print-loop (REPL) as follows.\n\n\nPkg.add(\nGillespie\n)\n\n\n\n\n\n\nExample\n\n\nLet's take the 'standard' \nsusceptible-infected-recovered (SIR) model\n, commonly used in epidemiology. A deterministic version of this model is as follows.\n\n\n\n\n\\begin{align} \\frac{dS(t)}{dt}  & = -\\beta S(t) I(t) \\cr \\frac{dI(t)}{dt}  & = \\beta S(t) I(t)- \\gamma I(t) \\cr \\frac{dR(t)}{dt}  & = \\gamma I(t) \\end{align}\n\n\n\n\nLet's consider a stochastic version of the SIR model.\n\n\n\n\n\\begin{align} {\\rm Transition} & \\quad {\\rm Rate} \\cr S  \\rightarrow S-1,\\; I \\rightarrow I+1 & \\quad \\beta S(t) I(t) \\cr I  \\rightarrow I-1,\\; R \\rightarrow R+1 & \\quad \\gamma I(t) \\end{align}\n\n\n\n\nWe first need to load the library.\n\n\nusing Gillespie;\n\n\n\n\nWe next need to define a function that given state variables \nx\n (type: \nArray{Int64,1}\n) and a vector of parameters (type: \nVector{Float64}\n), returns a vector of rates of length \nk\n for different types of transitions. For this example, there are two transition functions, corresponding to infection and recovery.\n\n\nfunction F(x,parms)\n  (S,I,R) = x\n  (beta,gamma) = parms\n  infection = beta*S*I\n  recovery = gamma*I\n  [infection,recovery]\nend;\n\n\n\n\nF (generic function with 1 method)\n\n\n\n\nWe define the states of the system - a \nVector{Int64}\n of length \nn\n with the number of susceptible, infected, and recovered individuals.\n\n\nx0 = [9999,1,0];\n\n\n\n\n3-element Array{Int64,1}:\n 9999\n    1\n    0\n\n\n\n\nTo define the transitions, we define an \nArray{Int64,k,n}\n that denotes the changes to each of the \nn\n state variables for each of the \nk\n transitions. Infection results in a loss of 1 susceptible and a gain of one infected individual, while recovery is associated with a loss of one infected and a gain of one recovered.\n\n\nnu = [[-1 1 0];[0 -1 1]];\n\n\n\n\n2x3 Array{Int64,2}:\n -1   1  0\n  0  -1  1\n\n\n\n\nFinally, we define the parameter values (in the order required by the function \nF\n), and the time we want the simulation to finish. The simulation will finish early if the propensity rates are zero.\n\n\nparms = [0.1/10000.0,0.05]\ntf = 1000.0;\n\n\n\n\n1000.0\n\n\n\n\nGiven the above, the simulation can be run using the function \nssa\n. It's usually a good idea to set a random number seed prior to simulation first.\n\n\nsrand(1236)\nresult = ssa(x0,F,nu,parms,tf);\n\n\n\n\nGillespie.SSAResult([0.0,11.7409,12.1425,17.647,18.0987,21.2081,22.2022,22.6326,26.1136,27.201  \u2026  413.431,413.962,414.973,420.548,422.656,424.17,424.486,430.513,433.936,482.663],15704x3 Array{Int64,2}:\n 9998  2     0\n 9998  2     0\n 9997  3     0\n 9996  4     0\n 9995  5     0\n 9994  6     0\n 9994  5     1\n 9994  4     2\n 9994  3     3\n 9993  4     3\n    \u22ee\n 2149  6  7845\n 2149  5  7846\n 2149  4  7847\n 2148  5  7847\n 2148  4  7848\n 2148  3  7849\n 2148  2  7850\n 2148  1  7851\n 2148  0  7852,Gillespie.SSAStats(\nzeroprop\n,15703),Gillespie.SSAArgs([9999,1,0],ex-1.F,2x3 Array{Int64,2}:\n -1   1  0\n  0  -1  1,[1.0e-5,0.05],1000.0))\n\n\n\n\nThis will return an object of type \nSSAresult\n. This can be converted to a \nDataFrame\n using the function \nssa_data\n.\n\n\ndata = ssa_data(result);\n\n\n\n\n15704\u00d74 DataFrames.DataFrame\n\u2502 Row   \u2502 time    \u2502 x1   \u2502 x2 \u2502 x3   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1     \u2502 0.0     \u2502 9998 \u2502 2  \u2502 0    \u2502\n\u2502 2     \u2502 11.7409 \u2502 9998 \u2502 2  \u2502 0    \u2502\n\u2502 3     \u2502 12.1425 \u2502 9997 \u2502 3  \u2502 0    \u2502\n\u2502 4     \u2502 17.647  \u2502 9996 \u2502 4  \u2502 0    \u2502\n\u2502 5     \u2502 18.0987 \u2502 9995 \u2502 5  \u2502 0    \u2502\n\u2502 6     \u2502 21.2081 \u2502 9994 \u2502 6  \u2502 0    \u2502\n\u2502 7     \u2502 22.2022 \u2502 9994 \u2502 5  \u2502 1    \u2502\n\u2502 8     \u2502 22.6326 \u2502 9994 \u2502 4  \u2502 2    \u2502\n\u22ee\n\u2502 15696 \u2502 413.962 \u2502 2149 \u2502 6  \u2502 7845 \u2502\n\u2502 15697 \u2502 414.973 \u2502 2149 \u2502 5  \u2502 7846 \u2502\n\u2502 15698 \u2502 420.548 \u2502 2149 \u2502 4  \u2502 7847 \u2502\n\u2502 15699 \u2502 422.656 \u2502 2148 \u2502 5  \u2502 7847 \u2502\n\u2502 15700 \u2502 424.17  \u2502 2148 \u2502 4  \u2502 7848 \u2502\n\u2502 15701 \u2502 424.486 \u2502 2148 \u2502 3  \u2502 7849 \u2502\n\u2502 15702 \u2502 430.513 \u2502 2148 \u2502 2  \u2502 7850 \u2502\n\u2502 15703 \u2502 433.936 \u2502 2148 \u2502 1  \u2502 7851 \u2502\n\u2502 15704 \u2502 482.663 \u2502 2148 \u2502 0  \u2502 7852 \u2502\n\n\n\n\nThis makes it straightforward to plot e.g. using \nGadfly\n.\n\n\nusing Gadfly\nplot(data,\n  layer(x=\ntime\n,y=\nx1\n,Geom.step,Theme(default_color=colorant\nred\n)),\n  layer(x=\ntime\n,y=\nx2\n,Geom.step,Theme(default_color=colorant\nblue\n)),\n  layer(x=\ntime\n,y=\nx3\n,Geom.step,Theme(default_color=colorant\ngreen\n)),\n  Guide.xlabel(\nTime\n),\n  Guide.ylabel(\nNumber\n),\n  Guide.manual_color_key(\nPopulation\n,\n                            [\nS\n, \nI\n, \nR\n],\n                            [\nred\n, \nblue\n, \ngreen\n]),\n  Guide.title(\nSIR epidemiological model\n))\n\n\n\n\n\n\n\n\nApplication programming interface\n\n\n\n\nTypes\n\n\n#\n\n\nGillespie.SSAStats\n \n \nType\n.\n\n\nA type storing the status at the end of a call to \nssa\n:\n\n\n\n\ntermination_status\n : whether the simulation stops at the final time (\nfinaltime\n) or early due to zero propensity function (\nzeroprop\n)\n\n\nnsteps\n : the number of steps taken during the simulation.\n\n\n\n\n#\n\n\nGillespie.SSAArgs\n \n \nType\n.\n\n\nA type storing the call to \nssa\n:\n\n\n\n\nx0\n : a \nVector\n of \nInt64\n, representing the initial states of the system.\n\n\nF\n : a \nFunction\n or a callable type, which itself takes two arguments; x, a \nVector\n of \nInt64\n representing the states, and parms, a \nVector\n of \nFloat64\n representing the parameters of the system.\n\n\nnu\n : a \nMatrix\n of \nInt64\n, representing the transitions of the system, organised by row.\n\n\nparms\n : a \nVector\n of \nFloat64\n representing the parameters of the system.\n\n\ntf\n : the final simulation time (\nFloat64\n)\n\n\n\n\n#\n\n\nGillespie.SSAResult\n \n \nType\n.\n\n\nThis type stores the output of \nssa\n, and comprises of:\n\n\n\n\ntime\n : a \nVector\n of \nFloat64\n, containing the times of simulated events.\n\n\ndata\n : a \nMatrix\n of \nInt64\n, containing the simulated states.\n\n\nstats\n : an instance of \nSSAStats\n.\n\n\nargs\n : arguments passed to \nssa\n.\n\n\n\n\n\n\nFunctions\n\n\n#\n\n\nGillespie.ssa\n \n \nFunction\n.\n\n\nThis function performs Gillespie's stochastic simulation algorithm. It takes the following arguments:\n\n\n\n\nx0\n : a \nVector\n of \nInt64\n, representing the initial states of the system.\n\n\nF\n : a \nFunction\n or a callable type, which itself takes two arguments; x, a \nVector\n of \nInt64\n representing the states, and parms, a \nVector\n of \nFloat64\n representing the parameters of the system.\n\n\nnu\n : a \nMatrix\n of \nInt64\n, representing the transitions of the system, organised by row.\n\n\nparms\n : a \nVector\n of \nFloat64\n representing the parameters of the system.\n\n\ntf\n : the final simulation time (\nFloat64\n)\n\n\n\n\n#\n\n\nGillespie.ssa_data\n \n \nFunction\n.\n\n\nThis takes a single argument of type \nSSAResult\n and returns a \nDataFrame\n.\n\n\n#\n\n\nGillespie.pfsample\n \n \nFunction\n.\n\n\nThis function is a substitute for \nStatsBase.sample(wv::WeightVec)\n, which avoids recomputing the sum and size of the weight vector, as well as a type conversion of the propensity vector. It takes the following arguments:\n\n\n\n\nw\n : an \nArray{Float64,1}\n, representing propensity function weights.\n\n\ns\n : the sum of \nw\n.\n\n\nn\n : the length of \nw\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#gillespiejl-stochastic-simulation-algorithm-in-julia", 
            "text": "Gillespie.jl: Stochastic Simulation Algorithm in Julia  Introduction  Installation  Example  Application programming interface", 
            "title": "Gillespie.jl: Stochastic Simulation Algorithm in Julia"
        }, 
        {
            "location": "/#introduction", 
            "text": "Gillespie.jl  provides an implementation of  Gillespie's direct method  for performing stochastic simulations, which are widely used in many fields, including systems biology and epidemiology. It borrows the basic interface (although none of the code) from the R library  GillespieSSA  by Mario Pineda-Krch, although  Gillespie.jl  only implements the standard exact method at present, whereas  GillespieSSA  also includes tau-leaping,  etc. .", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "Gillespie.jl  can be installed from the Julia read-eval-print-loop (REPL) as follows.  Pkg.add( Gillespie )", 
            "title": "Installation"
        }, 
        {
            "location": "/#example", 
            "text": "Let's take the 'standard'  susceptible-infected-recovered (SIR) model , commonly used in epidemiology. A deterministic version of this model is as follows.   \\begin{align} \\frac{dS(t)}{dt}  & = -\\beta S(t) I(t) \\cr \\frac{dI(t)}{dt}  & = \\beta S(t) I(t)- \\gamma I(t) \\cr \\frac{dR(t)}{dt}  & = \\gamma I(t) \\end{align}   Let's consider a stochastic version of the SIR model.   \\begin{align} {\\rm Transition} & \\quad {\\rm Rate} \\cr S  \\rightarrow S-1,\\; I \\rightarrow I+1 & \\quad \\beta S(t) I(t) \\cr I  \\rightarrow I-1,\\; R \\rightarrow R+1 & \\quad \\gamma I(t) \\end{align}   We first need to load the library.  using Gillespie;  We next need to define a function that given state variables  x  (type:  Array{Int64,1} ) and a vector of parameters (type:  Vector{Float64} ), returns a vector of rates of length  k  for different types of transitions. For this example, there are two transition functions, corresponding to infection and recovery.  function F(x,parms)\n  (S,I,R) = x\n  (beta,gamma) = parms\n  infection = beta*S*I\n  recovery = gamma*I\n  [infection,recovery]\nend;  F (generic function with 1 method)  We define the states of the system - a  Vector{Int64}  of length  n  with the number of susceptible, infected, and recovered individuals.  x0 = [9999,1,0];  3-element Array{Int64,1}:\n 9999\n    1\n    0  To define the transitions, we define an  Array{Int64,k,n}  that denotes the changes to each of the  n  state variables for each of the  k  transitions. Infection results in a loss of 1 susceptible and a gain of one infected individual, while recovery is associated with a loss of one infected and a gain of one recovered.  nu = [[-1 1 0];[0 -1 1]];  2x3 Array{Int64,2}:\n -1   1  0\n  0  -1  1  Finally, we define the parameter values (in the order required by the function  F ), and the time we want the simulation to finish. The simulation will finish early if the propensity rates are zero.  parms = [0.1/10000.0,0.05]\ntf = 1000.0;  1000.0  Given the above, the simulation can be run using the function  ssa . It's usually a good idea to set a random number seed prior to simulation first.  srand(1236)\nresult = ssa(x0,F,nu,parms,tf);  Gillespie.SSAResult([0.0,11.7409,12.1425,17.647,18.0987,21.2081,22.2022,22.6326,26.1136,27.201  \u2026  413.431,413.962,414.973,420.548,422.656,424.17,424.486,430.513,433.936,482.663],15704x3 Array{Int64,2}:\n 9998  2     0\n 9998  2     0\n 9997  3     0\n 9996  4     0\n 9995  5     0\n 9994  6     0\n 9994  5     1\n 9994  4     2\n 9994  3     3\n 9993  4     3\n    \u22ee\n 2149  6  7845\n 2149  5  7846\n 2149  4  7847\n 2148  5  7847\n 2148  4  7848\n 2148  3  7849\n 2148  2  7850\n 2148  1  7851\n 2148  0  7852,Gillespie.SSAStats( zeroprop ,15703),Gillespie.SSAArgs([9999,1,0],ex-1.F,2x3 Array{Int64,2}:\n -1   1  0\n  0  -1  1,[1.0e-5,0.05],1000.0))  This will return an object of type  SSAresult . This can be converted to a  DataFrame  using the function  ssa_data .  data = ssa_data(result);  15704\u00d74 DataFrames.DataFrame\n\u2502 Row   \u2502 time    \u2502 x1   \u2502 x2 \u2502 x3   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1     \u2502 0.0     \u2502 9998 \u2502 2  \u2502 0    \u2502\n\u2502 2     \u2502 11.7409 \u2502 9998 \u2502 2  \u2502 0    \u2502\n\u2502 3     \u2502 12.1425 \u2502 9997 \u2502 3  \u2502 0    \u2502\n\u2502 4     \u2502 17.647  \u2502 9996 \u2502 4  \u2502 0    \u2502\n\u2502 5     \u2502 18.0987 \u2502 9995 \u2502 5  \u2502 0    \u2502\n\u2502 6     \u2502 21.2081 \u2502 9994 \u2502 6  \u2502 0    \u2502\n\u2502 7     \u2502 22.2022 \u2502 9994 \u2502 5  \u2502 1    \u2502\n\u2502 8     \u2502 22.6326 \u2502 9994 \u2502 4  \u2502 2    \u2502\n\u22ee\n\u2502 15696 \u2502 413.962 \u2502 2149 \u2502 6  \u2502 7845 \u2502\n\u2502 15697 \u2502 414.973 \u2502 2149 \u2502 5  \u2502 7846 \u2502\n\u2502 15698 \u2502 420.548 \u2502 2149 \u2502 4  \u2502 7847 \u2502\n\u2502 15699 \u2502 422.656 \u2502 2148 \u2502 5  \u2502 7847 \u2502\n\u2502 15700 \u2502 424.17  \u2502 2148 \u2502 4  \u2502 7848 \u2502\n\u2502 15701 \u2502 424.486 \u2502 2148 \u2502 3  \u2502 7849 \u2502\n\u2502 15702 \u2502 430.513 \u2502 2148 \u2502 2  \u2502 7850 \u2502\n\u2502 15703 \u2502 433.936 \u2502 2148 \u2502 1  \u2502 7851 \u2502\n\u2502 15704 \u2502 482.663 \u2502 2148 \u2502 0  \u2502 7852 \u2502  This makes it straightforward to plot e.g. using  Gadfly .  using Gadfly\nplot(data,\n  layer(x= time ,y= x1 ,Geom.step,Theme(default_color=colorant red )),\n  layer(x= time ,y= x2 ,Geom.step,Theme(default_color=colorant blue )),\n  layer(x= time ,y= x3 ,Geom.step,Theme(default_color=colorant green )),\n  Guide.xlabel( Time ),\n  Guide.ylabel( Number ),\n  Guide.manual_color_key( Population ,\n                            [ S ,  I ,  R ],\n                            [ red ,  blue ,  green ]),\n  Guide.title( SIR epidemiological model ))", 
            "title": "Example"
        }, 
        {
            "location": "/#application-programming-interface", 
            "text": "", 
            "title": "Application programming interface"
        }, 
        {
            "location": "/#types", 
            "text": "#  Gillespie.SSAStats     Type .  A type storing the status at the end of a call to  ssa :   termination_status  : whether the simulation stops at the final time ( finaltime ) or early due to zero propensity function ( zeroprop )  nsteps  : the number of steps taken during the simulation.   #  Gillespie.SSAArgs     Type .  A type storing the call to  ssa :   x0  : a  Vector  of  Int64 , representing the initial states of the system.  F  : a  Function  or a callable type, which itself takes two arguments; x, a  Vector  of  Int64  representing the states, and parms, a  Vector  of  Float64  representing the parameters of the system.  nu  : a  Matrix  of  Int64 , representing the transitions of the system, organised by row.  parms  : a  Vector  of  Float64  representing the parameters of the system.  tf  : the final simulation time ( Float64 )   #  Gillespie.SSAResult     Type .  This type stores the output of  ssa , and comprises of:   time  : a  Vector  of  Float64 , containing the times of simulated events.  data  : a  Matrix  of  Int64 , containing the simulated states.  stats  : an instance of  SSAStats .  args  : arguments passed to  ssa .", 
            "title": "Types"
        }, 
        {
            "location": "/#functions", 
            "text": "#  Gillespie.ssa     Function .  This function performs Gillespie's stochastic simulation algorithm. It takes the following arguments:   x0  : a  Vector  of  Int64 , representing the initial states of the system.  F  : a  Function  or a callable type, which itself takes two arguments; x, a  Vector  of  Int64  representing the states, and parms, a  Vector  of  Float64  representing the parameters of the system.  nu  : a  Matrix  of  Int64 , representing the transitions of the system, organised by row.  parms  : a  Vector  of  Float64  representing the parameters of the system.  tf  : the final simulation time ( Float64 )   #  Gillespie.ssa_data     Function .  This takes a single argument of type  SSAResult  and returns a  DataFrame .  #  Gillespie.pfsample     Function .  This function is a substitute for  StatsBase.sample(wv::WeightVec) , which avoids recomputing the sum and size of the weight vector, as well as a type conversion of the propensity vector. It takes the following arguments:   w  : an  Array{Float64,1} , representing propensity function weights.  s  : the sum of  w .  n  : the length of  w .", 
            "title": "Functions"
        }
    ]
}